<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Controlling What’s in the PlotFile &mdash; IAMR 22.00-dev documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script>window.MathJax = {"tex": {"macros": {"Ab": "{{\\bf A}}", "eb": "{{\\bf e}}", "Fb": "{{\\bf F}}", "gb": "{{\\bf g}}", "Hb": "{{\\bf H}}", "ib": "{{\\bf i}}", "Ib": "{{\\bf I}}", "Kb": "{{\\bf K}}", "lb": "{{\\bf l}}", "Lb": "{{\\bf L}}", "nb": "{{\\bf n}}", "Pb": "{{\\bf P}}", "Qb": "{{\\bf Q}}", "rb": "{{\\bf r}}", "Rb": "{{\\bf R}}", "Sb": "{{\\bf S}}", "ub": "{{\\bf u}}", "Ub": "{{\\bf U}}", "xb": "{{\\bf x}}", "dt": "{\\Delta t}", "omegadot": "{\\dot\\omega}", "inp": "{{\\rm in}}", "outp": "{{\\rm out}}", "sync": "{{\\rm sync}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\half}", "nph": "{{n+\\myhalf}}", "vb": "{\\boldsymbol{v}}", "vbt": "{\\widetilde{\\vb}}", "rbt": "{\\widetilde{\\rb}}", "ob": "{\\boldsymbol{\\omega}}", "nablab": "{\\boldsymbol{\\nabla}}", "avg": ["{{\\left \\langle #1 \\right \\rangle}}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Algorithm and Software Details" href="AlgorithmAndSoftware.html" />
    <link rel="prev" title="Visualization" href="Visualization_Chapter.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> IAMR
          </a>
              <div class="version">
                22.00-dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction_Chapter.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Getting_Started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="SetupAndRunning.html">Creating and Running Your Own Problem</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Controlling What’s in the PlotFile</a></li>
<li class="toctree-l2"><a class="reference internal" href="#amrvis">Amrvis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#visit">VisIt</a></li>
<li class="toctree-l2"><a class="reference internal" href="#yt">yt</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#amrex-data-in-yt">AMReX Data in yt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interacting-with-yt-command-line-and-scripting">Interacting with yt: Command Line and Scripting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#yt-basics">yt Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-containers-and-selection">Data Containers and Selection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grid-inspection">Grid Inspection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-scripts">Example Scripts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="AlgorithmAndSoftware.html">Algorithm and Software Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="Debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Contributing.html">Contributing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">IAMR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="Visualization_Chapter.html">Visualization</a> &raquo;</li>
      <li>Controlling What’s in the PlotFile</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Visualization.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="controlling-whats-in-the-plotfile">
<h1>Controlling What’s in the PlotFile<a class="headerlink" href="#controlling-whats-in-the-plotfile" title="Permalink to this heading"></a></h1>
<p>There are a few options that can be set at runtime to control what
variables appear in the plotfile. See section <a class="reference internal" href="RunningProblems.html#sec-inputsplotfiles"><span class="std std-ref">Plotfiles</span></a>.</p>
</div>
<div class="section" id="amrvis">
<h1>Amrvis<a class="headerlink" href="#amrvis" title="Permalink to this heading"></a></h1>
<p>Amrvis is a package developed
by CCSE that is designed specifically for highly efficient visualization
of block-structured hierarchical AMR data.
Information on building the amrvis2d and amrvis3d executables is given in section
<a class="reference internal" href="Getting_Started.html#visualizing-the-results"><span class="std std-ref">Visualizing the Results</span></a>. A very useful feature of Amrvis is
View <span class="math notranslate nohighlight">\(\rightarrow\)</span> Dataset, which
allows you to actually view the numbers in a spreadsheet that is nested
to reflect the AMR hierarchy – this can be handy for
debugging. You can modify how many levels of data you want to see,
whether you want to see the grid boxes or not, what palette you use,
etc.</p>
<p>If you like to have amrvis display a certain variable, at a certain
scale, when you first bring up each plotfile (you can always change it
once the amrvis window is open), you can modify the amrvis.defaults
file in your directory to have amrvis default to these settings every
time you run it. The Amrvis repository has a sample amrvis.defaults
file that can be copied to your local folder and modified.</p>
</div>
<div class="section" id="visit">
<h1>VisIt<a class="headerlink" href="#visit" title="Permalink to this heading"></a></h1>
<p>VisIt is also a great visualization tool, and it supports AMReXAMR data natively. To open a AMReX plotfile, select File
<span class="math notranslate nohighlight">\(\rightarrow\)</span> Open file <span class="math notranslate nohighlight">\(\rightarrow\)</span> Open file as type Boxlib, and
choose the Header file within the plotfile folder, plt00000/Header,
For more information check out visit.llnl.gov.</p>
</div>
<div class="section" id="yt">
<h1>yt<a class="headerlink" href="#yt" title="Permalink to this heading"></a></h1>
<p>yt is a free and open-source software that provides data analysis and
publication-level visualization tools. It is geared more for astrophysical
simulation results, but may be useful for your purposes. As yt is script-based, it’s not
as easy to use as VisIt, and certainly not as easy as Amrvis, but the
images can be worth it! Here we do not flesh out yt, but give an
overview intended to get a person started. Full documentation and
explanations from which this section was adapted can be found at
<a class="reference external" href="http://yt-project.org/doc/index.html">http://yt-project.org/doc/index.html</a>.</p>
<p>yt can be installed by the following commands:</p>
<p>$ wget <a class="reference external" href="http://hg.yt-project.org/yt/raw/stable/doc/install_script.sh">http://hg.yt-project.org/yt/raw/stable/doc/install_script.sh</a></p>
<p>$ bash install_script.sh</p>
<p>This installs yt in your current directory. To update yt in the
future, simply do</p>
<p>$ yt update</p>
<p>in your “yt-hg” folder.</p>
<div class="section" id="amrex-data-in-yt">
<h2>AMReX Data in yt<a class="headerlink" href="#amrex-data-in-yt" title="Permalink to this heading"></a></h2>
<p>yt was originally created for simple analysis and visualization of
data from the Enzo code. Since, it has grown to include support for a
variety of codes, including IAMR.
However, yt will still sometimes
make assumptions, especially about data field names, that favor Enzo
and cause errors with AMReX data. These problems can usually be
avoided by taking care to specify the data fields desired in
visualization. For example, Enzo’s density field is called
“Density,” and is the default for many plotting mechanisms when the
user does not specify the field. However, IAMR does not have a field
called “Density”; instead, the density field is called “density.”
If a user does not specify a field while plotting with IAMR data,
chances are that yt will try (and fail) to find “Density” and return
an error. As you will see in the examples, however, there is a way to
create your own fields from existing ones. You can use these derived
fields as you would use any other field.</p>
<p>There are also a few imperatives when it comes to reading in your
AMReX simulation data and associated information. First and foremost
is that the inputs file for the simulation <strong>must</strong> exist in the
same directory as where the plotfile directory is located, and it <strong>must</strong> be named “<strong>inputs</strong>.” yt reads information from the
inputs file such as the number of levels in the simulation run, the
number of cells, the domain dimensions, and the simulation time.
When specifying a plotfile as
the data source for plots, you may simply call it by its directory
name, rather than using the Header file as in VisIt. As a final
caveat, yt requires the existence of the job_info file within the plotfile
directory.</p>
<p>The following examples for yt were taken from the Castro user guide,
and so have a strong astrophysics bent to them, but is still useful
in the context of combustion. The only subtlety is that Castro
works in CGS units.</p>
</div>
<div class="section" id="interacting-with-yt-command-line-and-scripting">
<h2>Interacting with yt: Command Line and Scripting<a class="headerlink" href="#interacting-with-yt-command-line-and-scripting" title="Permalink to this heading"></a></h2>
<p>yt is written completely in python (if you don’t have python, yt will
install it for you) and there are a number of different ways to
interact with it, including a web-based gui. Here we will cover
command-line yt and scripts/the python interactive prompt, but other
methods are outlined on the yt webpage at
<a class="reference external" href="http://yt-project.org/doc/interacting/index.html">http://yt-project.org/doc/interacting/index.html</a>.</p>
<p>The first step in starting up yt is to activate the yt environment:</p>
<p>$ source $YT_DEST/bin/activate</p>
<p>From the command line you can create simple plots, perform simple
volume renderings, print the statistics of a field for your data set,
and do a few other things. Try $ yt to see a list of commands,
and $ yt <span class="math notranslate nohighlight">\(&lt;\)</span>command<span class="math notranslate nohighlight">\(&gt;\)</span> –help
to see the details of a command. The command line is the easiest way
to get quick, preliminary plots – but the simplicity comes at a
price, as yt will make certain assumptions for you. We could plot a
projection of density along the x-axis for the plotfile (yt calls it a
parameter file) plt_def_00020 by doing the following:</p>
<p>$ yt plot -p -a 0 -f density plt_def_00020</p>
<p>Or a temperature-based volume rendering with 14 contours:</p>
<p>$ yt render -f Temp –contours 14 plt_def_00020</p>
<p>Any plots created from the command line will be saved into a
subfolder called “frames.” The command line is nice for fast
visualization without immersing yourself too much in the data, but
usually you’ll want to specify and control more details about your
plots. This can be done either through scripts or the python
interactive prompt. You can combine the two by running scripts within
the interactive prompt by the command</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> execfile(‘script.py’)</p>
<p>which will leave you in the interactive prompt, allowing you to
explore the data objects you’ve created in your script and debug
errors you may encounter. While in the yt environment, you can access
the interactive prompt by $ <em>python</em> or the shortcut</p>
<p>$ pyyt</p>
<p>Once you’re in the yt environment and in a .py script or the
interactive prompt, there are a couple of points to know about the
general layout of yt scripting. Usually there are five sections to a
yt script:</p>
<ol class="arabic simple">
<li><p>Import modules</p></li>
<li><p>Load parameter files and saved objects</p></li>
<li><p>Define variables</p></li>
<li><p>Create and modify data objects, image arrays, plots,
etc. <span class="math notranslate nohighlight">\(\rightarrow\)</span> this is the meat of the script</p></li>
<li><p>Save images and objects</p></li>
</ol>
<p>Note that neither saving nor loading objects is necessary, but can be
useful when the creation of these objects is time-consuming, which is
often the case during identification of clumps or contours.</p>
</div>
<div class="section" id="yt-basics">
<h2>yt Basics<a class="headerlink" href="#yt-basics" title="Permalink to this heading"></a></h2>
<p>The first thing you will always want to do is to import yt:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> from yt.mods import *</p>
<p>Under certain circumstances you will be required to import more, as we
will see in some of the examples, but this covers most of it,
including all of the primary functions and data objects provided by
yt. Next, you’ll need yt to access the plotfile you’re interested in
analyzing. Remember, you must have the “inputs” file in the same
folder:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> pf = load(‘plt_def_00020’)</p>
<p>When this line is executed, it will print out some key parameters from
the simulation. However, in order to access information about all of
the fluid quantities in the simulation, we must use the “hierarchy”
object. It contains the geometry of the grid zones, their parent
relationships, and the fluid states within each one. It is easily
created:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> pf.h</p>
<p>Upon execution, yt may print out a number of lines saying it’s adding
unknown fields to the list of fields. This is because IAMR has
different names for fields than what yt expects. We can see what
fields exist through the commands</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print pf.h.field_list</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print pf.h.derived_field_list</p>
<p>There may not be any derived fields for the IAMR data. We can find out
the number of grids and cells at each level, the simulation time, and
information about the finest resolution cells:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> pf.h.print_stats()</p>
<p>You can also find the value and location of the maximum of a field in
the domain:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> value, location = pf.h.find_max(‘density’)</p>
<p>The list goes on. A full list of methods and attributes associated
with the heirarchy object (and most any yt object or function) can be
accessed by the help function:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> help(pf.h)</p>
<p>You can also use <span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> <em>dir()</em> on an object or
function to find out which names it defines. Check the
yt documentation for help. Note that you may not always need to create
the hierarchy object. For example, before calling
functions like find_max; yt will construct it automatically if it
does not already exist.</p>
</div>
<div class="section" id="data-containers-and-selection">
<h2>Data Containers and Selection<a class="headerlink" href="#data-containers-and-selection" title="Permalink to this heading"></a></h2>
<p>Sometimes, you’ll want to select, analyze, or plot only portions of
your simulation data. To that end, yt includes a way to create data
“containers” that select data based on geometric bounds or fluid
quantity values. There are many, including rays, cylinders, and clumps
(some in the examples, all described in the documentation), but the
easiest to create is a sphere, centered on the location of the maximum
density cell we found above:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> my_data_container = pf.h.sphere(location, 5.0e4/pf[‘km’])</p>
<p>Here, we put the radius in units of kilometers using a
conversion. When specifying distances in yt, the default is to use the
simulation-native unit named “1”, which is probably identical to one
of the other units, like “m”. The pf.h.print_stats() command lists
available units. We can access the data within the container:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_data_container[‘density’]</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_data_container.quantities[‘Extrema’]([‘density’, ‘pressure’])</p>
<p>When the creation of objects is time-consuming, it can be convenient
to save objects so they can be used in another session. To save an
object as part of the .yt file affiliated with the heirarchy:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> pf.h.save_object(my_data_container, ‘sphere_to_analyze_later’)</p>
<p>Once it has been saved, it can be easily loaded later:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> sphere_to_analyze = pf.h.load_object(‘sphere_to_analyze_later’)</p>
</div>
<div class="section" id="grid-inspection">
<h2>Grid Inspection<a class="headerlink" href="#grid-inspection" title="Permalink to this heading"></a></h2>
<p>yt also allows for detailed grid inspection. The hierarchy object
possesses an array of grids, from which we can select and examine
specific ones:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print pf.h.grids</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> my_grid = pf.h.grids[4]</p>
<p>Each grid is a data object that carries information about its
location, parent-child relationships (grids within which it resides, and
grids that reside within it, at least in part), fluid quantities, and
more. Here are some of the commands:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_grid.Level</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_grid_ActiveDimensions</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_grid.LeftEdge</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_grid.RightEdge</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_grid.dds</p>
<p>(dds is the size of each cell within the grid).</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_grid.Parent</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_grid.Children[2].LeftEdge</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span> print my_grid[‘Density’]</p>
<p>You can examine which cells within the grid have been refined with the
child_mask attribute, a representative array set to zero everywhere
there is finer resolution.To find the fraction of your grid that isn’t
further refined:</p>
<p><span class="math notranslate nohighlight">\(&gt;&gt;&gt;\)</span>print my_grid.child_mask.sum()/float(my_grid.ActiveDimensions.prod())</p>
<p>Rather than go into detail about the many possibilities for plotting
in yt, we’ll provide some examples.</p>
</div>
<div class="section" id="example-scripts">
<h2>Example Scripts<a class="headerlink" href="#example-scripts" title="Permalink to this heading"></a></h2>
<p>In these examples, we investigate 3-D simulation data of two stars
orbiting in the center of the domain, which is a box of sides
<span class="math notranslate nohighlight">\(10^{10}\:cm\)</span>.</p>
<p><em># Pressure Contours</em></p>
<p>from yt.mods import *</p>
<p>pf = load(‘plt00020’)</p>
<p>field = ‘pressure’</p>
<p>pf.h</p>
<p><em># AMReX fields have no inherent units, so we add them in,
in the form of a raw string</em></p>
<p><em># with some LaTeX-style formatting.</em></p>
<p>pf.field_info[field]._units = r‘\rm{Ba}’</p>
<p><em># SlicePlot parameters include: parameter file, axis, field, window width (effectively the</em></p>
<p><em># x and y zoom), and fontsize. We can also create projections with ProjectionPlot().</em></p>
<p>p = SlicePlot(pf, ‘z’, field, width=((5.0e9, ‘cm’), (3.0e9, ‘cm’)),</p>
<p>fontsize=13)</p>
<p><em># Zlim is the range of the colorbar. In other words, the range of the data we want to display.</em></p>
<p><em># Names for many colormaps can be found at wiki.scipy.org/Cookbook/Matplotlib/Show_colormaps.</em></p>
<p>p.set_zlim(field, 2.85e13, 2.95e13)</p>
<p>p.set_cmap(field, ‘jet’)</p>
<p><em># Here we add 5 density contour lines within certain limits on top of the image. We overlay</em></p>
<p><em># our finest grids with a transparency of 0.2 (lower is more transparent). We add a quiver</em></p>
<p><em># plot with arrows every 16 pixels with x_velocity in the x-direction and y_velocity in</em></p>
<p><em># the y-direction. We also mark the center with an ‘x’ and label one of our stars.</em></p>
<p>p.annotate_contour(‘density’, clim=(1.05e-4, 1.16e-4), ncont=5, label=False)</p>
<p>p.annotate_grids(alpha=0.2, min_level=2)</p>
<p>p.annotate_quiver(‘x_velocity’, ‘y_velocity’, factor=16)</p>
<p>p.annotate_marker([5.0e9, 5.0e9], marker=‘x’)</p>
<p>p.annotate_point([5.95e9, 5.1e9], ‘Star!’)</p>
<p><em># This saves the plot to a file with the given prefix. We can alternatively specify</em></p>
<p><em># the entire filename.</em></p>
<p>p.save(‘contours.press_den_’)</p>
<div class="figure align-default" id="id1">
<a class="reference internal image-reference" href="_images/Slice_z_pressure.png"><img alt="Pressure slice with annotations" src="_images/Slice_z_pressure.png" style="width: 6.00000in;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Pressure slice with annotations</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</div>
<p><em>#————————</em></p>
<p><em># Volume Rendering</em></p>
<p>from yt.mods import *</p>
<p>pf = load(‘plt00020’)</p>
<p>field = ‘pressure’
dd = pf.h.all_data()</p>
<p><em># We take the log of the extrema of the pressure field, as well as a couple other interesting</em></p>
<p><em># value ranges we’d like to visualize.</em></p>
<p>h_mi, h_ma = dd.quantities[‘Extrema’](field)[0]</p>
<p>h_mi, h_ma = np.log10(h_mi), np.log10(h_ma)</p>
<p>s_mi, s_ma = np.log10(2.90e13), np.log10(3.10e13)</p>
<p>pf.h</p>
<p><em># We deal in terms of logarithms here because we have such a large range of values.</em></p>
<p><em># It can make things easier, but is not necessary.</em></p>
<p>pf.field_info[field].take_log=True</p>
<p><em># This is what we use to visualize volumes. There are a couple of other, more complex</em></p>
<p><em># ways. We set the range of values we’re interested in and the number of bins in the</em></p>
<p><em># function. Make sure to have a lot of bins if your data spans many orders of magnitude!</em></p>
<p><em># Our raw data ranges from about :math:`10^{13}` to :math:`10^{22}`.</em></p>
<p>tf = ColorTransferFunction((h_mi-1, h_ma+1), nbins=1.0e6)</p>
<p><em># Here we add several layers to our function, either one at a time or in groups. We</em></p>
<p><em># specify the value-center and width of the layer. We can manipulate the color by</em></p>
<p><em># individually setting the colormaps and ranges to spread them over. We can also</em></p>
<p><em># change the transparency, which will usually take some time to get perfect.</em></p>
<p>tf.sample_colormap(np.log10(2.0e21), 0.006, col_bounds=[h_mi,h_ma],</p>
<p>alpha=[27.0], colormap=‘RdBu_r’)</p>
<p>tf.sample_colormap(np.log10(2.0e19), 0.001, col_bounds=[h_mi,h_ma],</p>
<p>alpha=[5.5], colormap=‘RdBu_r’)</p>
<p>tf.add_layers(6, mi=np.log10(2.95e13), ma=s_ma,</p>
<p>col_bounds=[s_mi,s_ma],</p>
<p>alpha=19*na.ones(6,dtype=‘float64’), colormap=‘RdBu_r’)</p>
<p>tf.sample_colormap(np.log10(2.95e13), 0.000005, col_bounds=[s_mi,s_ma],</p>
<p>alpha=[13.0], colormap=‘RdBu_r’)</p>
<p>tf.sample_colormap(np.log10(2.90e13), 0.000007, col_bounds=[s_mi,s_ma],</p>
<p>alpha=[11.5], colormap=‘RdBu_r’)</p>
<p>tf.sample_colormap(np.log10(2.85e13), 0.000008, col_bounds=[s_mi,s_ma],</p>
<p>alpha=[9.5], colormap=‘RdBu_r’)</p>
<p><em># By default each color channel is only opaque to itself. If we set grey_opacity=True,</em></p>
<p><em># this is no longer the case. This is good to use if we want to obscure the inner</em></p>
<p><em># portions of our rendering. Here it only makes a minor change, as we must set our</em></p>
<p><em># alpha values for the outer layers higher to see a strong effect.</em></p>
<p>tf.grey_opacity=True</p>
<p><em># Volume rendering uses a camera object which centers the view at the coordinates we’ve</em></p>
<p><em># called ‘c.’ ‘L’ is the normal vector (automatically normalized) between the camera</em></p>
<p><em># position and ‘c,’ and ‘W’ determines the width of the image—again, like a zoom.</em></p>
<p><em># ‘Nvec’ is the number of pixels in the x and y directions, so it determines the actual</em></p>
<p><em># size of the image.</em></p>
<p>c = [5.0e9, 5.0e9, 5.0e9]</p>
<p>L = [0.15, 1.0, 0.40]</p>
<p>W = (pf.domain_right_edge - pf.domain_left_edge)*0.5</p>
<p>Nvec = 768</p>
<p><em># ‘no_ghost’ is an optimization option that can speed up calculations greatly, but can</em></p>
<p><em># also create artifacts at grid edges and affect smoothness. For our data, there is no</em></p>
<p><em># speed difference, so we opt for a better-looking image.</em></p>
<p>cam = pf.h.camera(c, L, W, (Nvec,Nvec), transfer_function = tf,</p>
<p>fields=[field], pf=pf, no_ghost=False)</p>
<p><em># Obtain an image! However, we’ll want to annotate it with some other things before</em></p>
<p><em># saving it.</em></p>
<p>im = cam.snapshot()</p>
<p><em># Here we draw a box around our stars, and visualize the gridding of the top two levels.</em></p>
<p><em># Note that draw_grids returns a new image while draw_box does not. Also, add_</em></p>
<p><em># background_color in front of draw_box is necessary to make the box appear over</em></p>
<p><em># blank space (draw_grids calls this internally). For draw_box we specify the left</em></p>
<p><em># (lower) and right(upper) bounds as well its color and transparency.</em></p>
<p>im.add_background_color(‘black’, inline=True)</p>
<p>cam.draw_box(im, np.array([3.0e9, 4.0e9, 4.0e9]),</p>
<p>np.array([7.0e9, 6.0e9, 6.0e9]), np.array([1.0, 1.0, 1.0, 0.14]))</p>
<p>im = cam.draw_grids(im, alpha=0.12, min_level=2)</p>
<p>im = cam.draw_grids(im, alpha=0.03, min_level=1, max_level=1)</p>
<p><em># ‘im’ is an image array rather than a plot object, so we save it using a different</em></p>
<p><em># function. There are others, such as ‘write_bitmap.’</em></p>
<p>im.write_png(‘pressure_shell_volume.png’)</p>
<div class="figure align-default" id="id2">
<a class="reference internal image-reference" href="_images/volume.png"><img alt="Volume rendering" src="_images/volume.png" style="width: 3.50000in;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Volume rendering</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</div>
<p><em>#————————</em></p>
<p><em># Isocontour Rendering</em></p>
<p><em># Here we extract isocontours using some extra modules and plot them using matplotlib.</em></p>
<p>from mpl_toolkits.mplot3d import Axes3D</p>
<p>from mpl_toolkits.mplot3d.art3d import Poly3DCollection</p>
<p>import matplotlib.pyplot as plt</p>
<p>from yt.mods import *</p>
<p>pf = load(‘plt00020’)</p>
<p>field = ‘pressure’</p>
<p>field_weight = ‘magvel’</p>
<p>contour_value = 2.83e13</p>
<p>domain = pf.h.all_data()</p>
<p><em># This object identifies isocontours at a given value for a given field. It returns</em></p>
<p><em># the vertices of the triangles in that isocontour. It requires a data source, which</em></p>
<p><em># can be an object—but here we just give it all of our data. Here we find a pressure</em></p>
<p><em># isocontour and color it the magnitude of velocity over the same contour.</em></p>
<p>surface = pf.h.surface(domain, field, contour_value)</p>
<p>colors = apply_colormap(np.log10(surface[field_weight]), cmap_name=‘RdBu’)</p>
<p>fig = plt.figure()</p>
<p>ax = fig.gca(projection=‘3d’)</p>
<p>p3dc = Poly3DCollection(surface.triangles, linewidth=0.0)</p>
<p>p3dc.set_facecolors(colors[0,:,:]/255.)</p>
<p>ax.add_collection(p3dc)</p>
<p><em># By setting the scaling on the plot to be the same in all directions (using the x scale),</em></p>
<p><em># we ensure that no warping or stretching of the data occurs.</em></p>
<p>ax.auto_scale_xyz(surface.vertices[0,:], surface.vertices[0,:],</p>
<p>surface.vertices[0,:])</p>
<p>ax.set_aspect(1.0)</p>
<p>plt.savefig(‘pres_magvel_isocontours.png’)</p>
<div class="figure align-default" id="id3">
<a class="reference internal image-reference" href="_images/isocontours.png"><img alt="Pressure isocontour rendering colored with velocity magnitude" src="_images/isocontours.png" style="width: 4.00000in;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Pressure isocontour rendering colored with velocity magnitude</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</div>
<p><em>#————————</em></p>
<p><em>#1-D and 2-D Profiles</em></p>
<p><em># Line plots and phase plots can be useful for analyzing data in detail.</em></p>
<p>from yt.mods import *</p>
<p>pf = load(‘plt00020’)</p>
<p>pf.h</p>
<p><em># Just like with the pressure_contours script, we can set the units for fields that</em></p>
<p><em># have none.</em></p>
<p>pf.field_info[‘magvel’]._units = r‘\rm{cm}/\rm{s}’</p>
<p>pf.field_info[‘kineng’]._units = r‘\rm{ergs}’</p>
<p><em># We can create new fields from existing ones. ytassumes all units are in cgs, and</em></p>
<p><em># does not do any unit conversions on its own (but we can make it). Creating new fields</em></p>
<p><em># requires us to define a function that acts on our data and returns the new data,</em></p>
<p><em># then call add_field while supplying the field name, the function the data comes from,</em></p>
<p><em># and the units. Here, we create new fields simply to rename our data to make the plot</em></p>
<p><em># look prettier.</em></p>
<p>def _newT(field, data):</p>
<p>return data[‘t’]</p>
<p>add_field(‘X’, function=_newT, units=r‘\rm{domain}\rm{fraction}’)</p>
<p>def _newDen(field, data):</p>
<p>return data[‘density’]</p>
<p>add_field(‘Density’, function=_newDen, units=r‘\rm{g}/\rm{cm}^{3}’)</p>
<p><em># PlotCollections are one of the most commonly used tools in yt, alongside SlicePlots and</em></p>
<p><em># ProjectionPlots. They are useful when we want to create multiple plots from the same</em></p>
<p><em># parameter file, linked by common characteristics such as the colormap, its bounds, and</em></p>
<p><em># the image width. It is easy to create 1-D line plots and 2-D phase plots through a</em></p>
<p><em># PlotCollection, but we can also create thin projections and so on. When we create a</em></p>
<p><em># PlotCollection, it is empty, and only requires the parameter file and the ’center’ that</em></p>
<p><em># will be supplied to plots like slices and sphere plots.</em></p>
<p>pc = PlotCollection(pf, ‘c’)</p>
<p><em># Now we add a ray—a sample of our data field along a line between two points we define</em></p>
<p><em># in the function call.</em></p>
<p>ray = pc.add_ray([0.0, 5.0e9, 5.0e9],[1.e10, 5.0e9, 5.0e9], ‘magvel’)</p>
<p><em># This is where our derived fields come in handy. Our ray is drawn along the x-axis</em></p>
<p><em># through the center of the domain, but by default the fraction of the ray we have gone</em></p>
<p><em># along is called ‘t.’ We now have the same data in another field we called ‘X,’ whose</em></p>
<p><em># name makes more sense, so we’ll reassign the ray’s first field to be that. If we wanted,</em></p>
<p>(<em># we could also reassign names to ‘magvel’ and ‘kineng.’</em></p>
<p>ray.fields = [‘X’, ‘magvel’]</p>
<p><em># Next, we’ll create a phase plot. The function requires a data source, and we can’t</em></p>
<p><em># just hand it our parameter file, but as a substitute we can quickly create an object</em></p>
<p><em># that spans our entire domain (or use the method in the isocontour example). The</em></p>
<p><em># specifications of the region (a box) are the center, left bound, and right bound.</em></p>
<p>region = pf.h.region([5.0e9, 5.0e9, 5.0e9], [0.0, 0.0, 0.0],</p>
<p>[1.0e10, 1.0e10, 1.0e10])</p>
<p><em># The phase object accepts a data source, fields, a weight, a number of bins along both</em></p>
<p><em># axes, and several other things, including its own colormap, logarithm options,</em></p>
<p><em># normalization options, and an accumulation option. The first field is binned onto</em></p>
<p><em># the x-axis, the second field is binned onto the y-axis, and the third field is</em></p>
<p><em># binned with the colormap onto the other two. Subsequent fields go into an underlying</em></p>
<p><em># profile and do not appear on the image.</em></p>
<p>phase = pc.add_phase_object(region, [‘Density’, ‘magvel’,‘kineng’], weight=None,</p>
<p>x_bins=288, y_bins=288)</p>
<p>pc.save(‘profile’)</p>
<div class="figure align-default" id="id4">
<a class="reference internal image-reference" href="_images/LineQueryPlot_0_t_magvel.png"><img alt="Density/velocity magnitude/kinetic energy phase plot" src="_images/LineQueryPlot_0_t_magvel.png" style="width: 4.00000in;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Density/velocity magnitude/kinetic energy phase plot</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</div>
<div class="figure align-default" id="id5">
<a class="reference internal image-reference" href="Visualization/Profile2D_1_Density_magveel_kineng.png"><img alt="Density/velocity magnitude/kinetic energy phase plot" src="Visualization/Profile2D_1_Density_magveel_kineng.png" style="width: 4.00000in;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Density/velocity magnitude/kinetic energy phase plot</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</div>
<p><em>#————————</em></p>
<p><em>#Off-Axis Projection</em></p>
<p><em># If we don’t want to take a projection (this can be done for a slice as well) along</em></p>
<p><em># one of the coordinate axes, we can take one from any direction using an</em></p>
<p><em># OffAxisProjectionPlot. To accomplish the task of setting the view up, the plot</em></p>
<p><em># requires some of the same parameters as the camera object: a normal vector, center,</em></p>
<p><em># width, and field, and optionally we can set no_ghost (default is False). The normal</em></p>
<p><em># vector is automatically normalized as in the case of the camera. The plot also</em></p>
<p><em># requires a depth—that is, how much data we want to sample along the line of sight,</em></p>
<p><em># centered around the center. In this case ‘c’ is a shortcut for the domain center.</em></p>
<p>pf = load(‘plt00020’)</p>
<p>field = ‘density’</p>
<p>L = [0.25, 0.9, 0.40]</p>
<p>plot = OffAxisProjectionPlot(pf, L, field, center=‘c’,</p>
<p>width=(5.0e9, 4.0e9), depth=3.0e9)</p>
<p><em># Here we customize our newly created plot, dictating the font, colormap, and title.</em></p>
<p><em># Logarithmic data is used by default for this plot, so we turn it off.</em></p>
<p>plot.set_font({‘family’:‘Bitstream Vera Sans’, ‘style’:‘italic’,</p>
<p>‘weight’:‘normal’, ‘size’:14, ‘color’:‘red’})</p>
<p>plot.set_log(field, False)</p>
<p>plot.set_cmap(field, ‘jet’)</p>
<p>plot.annotate_title(‘Off-Axis Density Projection’)</p>
<p><em># The actual size of the image can also be set. Note that the units are in inches.</em></p>
<p>plot.set_window_size(8.0)</p>
<p>plot.save(‘off_axis_density’)</p>
<div class="figure align-default" id="id6">
<a class="reference internal image-reference" href="_images/OffAxisProjection_density.png"><img alt="Off-axis density projection" src="_images/OffAxisProjection_density.png" style="width: 4.00000in;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Off-axis density projection</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Visualization_Chapter.html" class="btn btn-neutral float-left" title="Visualization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="AlgorithmAndSoftware.html" class="btn btn-neutral float-right" title="Algorithm and Software Details" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2018, IAMR Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>